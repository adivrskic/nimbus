<!DOCTYPE html>
<html>
  <head>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      body {
        overflow: hidden;
        background: transparent;
      }
      canvas {
        display: block;
        opacity: 0;
        transition: opacity 1s ease-in;
      }
      canvas.ready {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { mergeVertices } from "three/addons/utils/BufferGeometryUtils.js";

      const params = new URLSearchParams(window.location.search);
      const bgColor = params.get("bg") || "#ffffff";
      const blobColor = params.get("color") || "#ffffff";
      const emissive = params.get("emissive") || "#0000ff";
      const speed = parseFloat(params.get("speed") || "0.15");

      const isMobile =
        window.innerWidth <= 768 ||
        (window.innerWidth <= 1024 && window.innerHeight > window.innerWidth);

      const noiseGLSL = `
      vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
      float permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}
      vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
      vec4 grad4(float j, vec4 ip){
        const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
        vec4 p,s;
        p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
        p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
        s = vec4(lessThan(p, vec4(0.0)));
        p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; 
        return p;
      }
      float snoise(vec4 v){
        const vec2 C = vec2(0.138196601125010504, 0.309016994374947451);
        vec4 i = floor(v + dot(v, C.yyyy));
        vec4 x0 = v - i + dot(i, C.xxxx);
        vec4 i0;
        vec3 isX = step(x0.yzw, x0.xxx);
        vec3 isYZ = step(x0.zww, x0.yyz);
        i0.x = isX.x + isX.y + isX.z;
        i0.yzw = 1.0 - isX;
        i0.y += isYZ.x + isYZ.y;
        i0.zw += 1.0 - isYZ.xy;
        i0.z += isYZ.z;
        i0.w += 1.0 - isYZ.z;
        vec4 i3 = clamp(i0, 0.0, 1.0);
        vec4 i2 = clamp(i0-1.0, 0.0, 1.0);
        vec4 i1 = clamp(i0-2.0, 0.0, 1.0);
        vec4 x1 = x0 - i1 + C.xxxx;
        vec4 x2 = x0 - i2 + 2.0 * C.xxxx;
        vec4 x3 = x0 - i3 + 3.0 * C.xxxx;
        vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;
        i = mod(i, 289.0);
        float j0 = permute(permute(permute(permute(i.w) + i.z) + i.y) + i.x);
        vec4 j1 = permute(permute(permute(permute(
          i.w + vec4(i1.w, i2.w, i3.w, 1.0))
          + i.z + vec4(i1.z, i2.z, i3.z, 1.0))
          + i.y + vec4(i1.y, i2.y, i3.y, 1.0))
          + i.x + vec4(i1.x, i2.x, i3.x, 1.0));
        vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0);
        vec4 p0 = grad4(j0, ip);
        vec4 p1 = grad4(j1.x, ip);
        vec4 p2 = grad4(j1.y, ip);
        vec4 p3 = grad4(j1.z, ip);
        vec4 p4 = grad4(j1.w, ip);
        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
        p4 *= taylorInvSqrt(dot(p4,p4));
        vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
        vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)), 0.0);
        m0 = m0 * m0; m1 = m1 * m1;
        return 49.0 * (dot(m0*m0, vec3(dot(p0,x0), dot(p1,x1), dot(p2,x2)))
          + dot(m1*m1, vec2(dot(p3,x3), dot(p4,x4))));
      }
    `;

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(bgColor);

      const baseScale = isMobile ? 3.5 * 1.4 : 3.5;
      const cameraY = isMobile ? 6 : 0;

      const camera = new THREE.PerspectiveCamera(
        70,
        window.innerWidth / window.innerHeight,
        1,
        1000
      );
      camera.position.set(0, cameraY, 10);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.enablePan = false;
      controls.enableZoom = true;

      const uniforms = {
        time: { value: 0 },
        noiseScale: { value: 0.875 },
        noiseAmplitude: { value: 0.35 },
        baseScale: { value: baseScale },
      };

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
      dirLight.position.setScalar(1);
      scene.add(dirLight);
      scene.add(new THREE.HemisphereLight(0xffff00, 0x0000ff, 0.375));
      scene.add(new THREE.AmbientLight(0xffffff, 1));

      let geometry = new THREE.IcosahedronGeometry(1, 250);
      geometry.deleteAttribute("normal");
      geometry.deleteAttribute("uv");
      geometry = mergeVertices(geometry);
      geometry.computeVertexNormals();

      const material = new THREE.MeshPhongMaterial({
        color: new THREE.Color(blobColor),
        emissive: new THREE.Color(emissive).multiplyScalar(0.05),
        shininess: 300,
      });

      material.onBeforeCompile = (shader) => {
        shader.uniforms.time = uniforms.time;
        shader.uniforms.noiseScale = uniforms.noiseScale;
        shader.uniforms.noiseAmplitude = uniforms.noiseAmplitude;
        shader.uniforms.baseScale = uniforms.baseScale;

        shader.vertexShader = `
        uniform float time;
        uniform float noiseScale;
        uniform float noiseAmplitude;
        uniform float baseScale;
        ${noiseGLSL}
        float noise(vec3 p){
          float n = snoise(vec4(p, time));
          n = sin(n * 3.1415926 * 8.);
          n = n * 0.5 + 0.5;
          n *= n;
          return n;
        }
        vec3 getPos(vec3 p){
          return p * (baseScale + noise(p * noiseScale) * noiseAmplitude);
        }
        ${shader.vertexShader}
      `
          .replace(
            "#include <beginnormal_vertex>",
            `#include <beginnormal_vertex>
        vec3 p0 = getPos(position);
        float theta = .1;
        vec3 vecTangent = normalize(cross(p0, vec3(1.0, 0.0, 0.0)) + cross(p0, vec3(0.0, 1.0, 0.0)));
        vec3 vecBitangent = normalize(cross(vecTangent, p0));
        vec3 ptTangentSample = getPos(normalize(p0 + theta * normalize(vecTangent)));
        vec3 ptBitangentSample = getPos(normalize(p0 + theta * normalize(vecBitangent)));
        objectNormal = normalize(cross(ptBitangentSample - p0, ptTangentSample - p0));
        `
          )
          .replace(
            "#include <begin_vertex>",
            `#include <begin_vertex>
        transformed = p0;
        `
          );
      };

      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      const clock = new THREE.Clock();

      requestAnimationFrame(() => {
        renderer.domElement.classList.add("ready");
        window.parent.postMessage({ type: "blob-ready" }, "*");
      });

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        uniforms.time.value = clock.getElapsedTime() * speed;
        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
